
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite -- YosysHQ Edition [202106071139]     |
 |                                                                            |
 |  Copyright (C) 2012 - 2021 YosysHQ GmbH                                    |
 |                                                                            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9+4081 (git sha1 8cfed1a9, clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Executing script file `fmdemo.ys' --

1. Executing Verilog-2005 frontend: fmdemo.sv
Parsing formal SystemVerilog input from `fmdemo.sv' to AST representation.
Storing AST representation for module `$abstract\fmdemo'.
Successfully finished Verilog frontend.

2. Executing PREP pass.

2.1. Executing HIERARCHY pass (managing design hierarchy).

2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\fmdemo'.
Generating RTLIL representation for module `\fmdemo'.

2.2.1. Analyzing design hierarchy..
Top module:  \fmdemo

2.2.2. Analyzing design hierarchy..
Top module:  \fmdemo
Removing unused module `$abstract\fmdemo'.
Removed 1 unused modules.
Module fmdemo directly or indirectly contains formal properties -> setting "keep" attribute.

2.3. Executing PROC pass (convert processes to netlists).

2.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

2.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

2.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 6 assignments to connections.

2.3.4. Executing PROC_INIT pass (extract init attributes).

2.3.5. Executing PROC_ARST pass (detect async resets in processes).

2.3.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\fmdemo.$proc$fmdemo.sv:0$18'.
Creating decoders for process `\fmdemo.$proc$fmdemo.sv:0$12'.
Creating decoders for process `\fmdemo.$proc$fmdemo.sv:16$11'.
Creating decoders for process `\fmdemo.$proc$fmdemo.sv:0$4'.

2.3.7. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\fmdemo.$formal$fmdemo.sv:20$1_CHECK' from process `\fmdemo.$proc$fmdemo.sv:0$18'.
No latch inferred for signal `\fmdemo.$formal$fmdemo.sv:20$1_EN' from process `\fmdemo.$proc$fmdemo.sv:0$18'.
No latch inferred for signal `\fmdemo.$formal$fmdemo.sv:21$3_CHECK' from process `\fmdemo.$proc$fmdemo.sv:0$12'.
No latch inferred for signal `\fmdemo.$formal$fmdemo.sv:21$3_EN' from process `\fmdemo.$proc$fmdemo.sv:0$12'.
No latch inferred for signal `\fmdemo.\next_state' from process `\fmdemo.$proc$fmdemo.sv:0$4'.

2.3.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\fmdemo.\state' using process `\fmdemo.$proc$fmdemo.sv:16$11'.
  created $dff cell `$procdff$22' with positive edge clock.

2.3.9. Executing PROC_MEMWR pass (convert process memory writes to cells).

2.3.10. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `fmdemo.$proc$fmdemo.sv:0$18'.
Removing empty process `fmdemo.$proc$fmdemo.sv:0$12'.
Removing empty process `fmdemo.$proc$fmdemo.sv:16$11'.
Removing empty process `fmdemo.$proc$fmdemo.sv:0$4'.
Cleaned up 0 empty switches.

2.4. Executing OPT_EXPR pass (perform const folding).
Optimizing module fmdemo.
<suppressed ~5 debug messages>

2.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \fmdemo..
Removed 0 unused cells and 14 unused wires.
<suppressed ~1 debug messages>

2.6. Executing CHECK pass (checking for obvious problems).
Checking module fmdemo...
Found and reported 0 problems.

2.7. Executing OPT pass (performing simple optimizations).

2.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module fmdemo.

2.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\fmdemo'.
<suppressed ~3 debug messages>
Removed a total of 1 cells.

2.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \fmdemo..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

2.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \fmdemo.
Performed a total of 0 changes.

2.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\fmdemo'.
Removed a total of 0 cells.

2.7.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \fmdemo..
Removed 0 unused cells and 1 unused wires.
<suppressed ~1 debug messages>

2.7.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module fmdemo.

2.7.8. Rerunning OPT passes. (Maybe there is more to do..)

2.7.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \fmdemo..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

2.7.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \fmdemo.
Performed a total of 0 changes.

2.7.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\fmdemo'.
Removed a total of 0 cells.

2.7.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \fmdemo..

2.7.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module fmdemo.

2.7.14. Finished OPT passes. (There is nothing left to do.)

2.8. Executing WREDUCE pass (reducing word size of cells).
Removed top 17 bits (of 32) from port B of cell fmdemo.$add$fmdemo.sv:12$8 ($add).

2.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \fmdemo..

2.10. Executing MEMORY_COLLECT pass (generating $mem cells).

2.11. Executing OPT pass (performing simple optimizations).

2.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module fmdemo.

2.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\fmdemo'.
Removed a total of 0 cells.

2.11.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \fmdemo..

2.11.4. Finished fast OPT passes.

2.12. Printing statistics.

=== fmdemo ===

   Number of wires:                  7
   Number of wire bits:            131
   Number of public wires:           3
   Number of public wire bits:      65
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     $add                            3
     $assert                         1
     $assume                         1
     $dff                            1
     $initstate                      1
     $reduce_bool                    1

2.13. Executing CHECK pass (checking for obvious problems).
Checking module fmdemo...
Found and reported 0 problems.

3. Executing SAT pass (solving SAT problems in the circuit).

Setting up time step 1:
Final constraint equation: { } = { }
Imported 8 cells to SAT database.
Import constraint from assume cell: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when $0$formal$fmdemo.sv:20$1_EN[0:0]$20.
Import proof for assert: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when 1'1.

** Trying induction with length 1 **

Setting up time step 1:
Final constraint equation: { } = { }
Imported 8 cells to SAT database.
Import constraint from assume cell: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when $0$formal$fmdemo.sv:20$1_EN[0:0]$20.
No constraints for initial state found.

Import proof for assert: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when 1'1.
Import show expression: \clock
Import show expression: \state

[base case 1] Solving problem with 1164 variables and 3225 clauses..
Base case for induction length 1 proven.

Setting up time step 2:
Final constraint equation: { } = { }
Imported 8 cells to SAT database.
Import constraint from assume cell: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when $0$formal$fmdemo.sv:20$1_EN[0:0]$20.
Import proof for assert: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when 1'1.
Import show expression: \clock
Import show expression: \state

[induction step 1] Solving problem with 2422 variables and 6769 clauses..
Induction step failed. Incrementing induction length.

  Time Signal Name             Dec       Hex                                 Bin
  ---- --------------- ----------- --------- -----------------------------------
  init \state            335503361  13ff6001    00010011111111110110000000000001
  ---- --------------- ----------- --------- -----------------------------------
     1 \clock                    0         0                                   0
     1 \state            335503361  13ff6001    00010011111111110110000000000001
  ---- --------------- ----------- --------- -----------------------------------
     2 \clock                    0         0                                   0
     2 \state                    0         0    00000000000000000000000000000000

** Trying induction with length 2 **

Setting up time step 2:
Final constraint equation: { } = { }
Imported 8 cells to SAT database.
Import constraint from assume cell: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when $0$formal$fmdemo.sv:20$1_EN[0:0]$20.
Import proof for assert: $0$formal$fmdemo.sv:20$1_CHECK[0:0]$19 when 1'1.
Import show expression: \clock
Import show expression: \state

[base case 2] Solving problem with 2519 variables and 7091 clauses..
SAT temporal induction proof finished - model found for base case: FAIL!

   ______                   ___       ___       _ _            _ _ 
  (_____ \                 / __)     / __)     (_) |          | | |
   _____) )___ ___   ___ _| |__    _| |__ _____ _| | _____  __| | |
  |  ____/ ___) _ \ / _ (_   __)  (_   __|____ | | || ___ |/ _  |_|
  | |   | |  | |_| | |_| || |       | |  / ___ | | || ____( (_| |_ 
  |_|   |_|   \___/ \___/ |_|       |_|  \_____|_|\_)_____)\____|_|


  Time Signal Name             Dec       Hex                                 Bin
  ---- --------------- ----------- --------- -----------------------------------
  init \state            335503361  13ff6001    00010011111111110110000000000001
  ---- --------------- ----------- --------- -----------------------------------
     1 \clock                    0         0                                   0
     1 \state            335503361  13ff6001    00010011111111110110000000000001
  ---- --------------- ----------- --------- -----------------------------------
     2 \clock                    0         0                                   0
     2 \state                    0         0    00000000000000000000000000000000

End of script. Logfile hash: 258e525f64, CPU: user 0.08s system 0.01s, MEM: 26.64 MB peak
Yosys 0.9+4081 (git sha1 8cfed1a9, clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 60% 1x sat (0 sec), 9% 5x opt_clean (0 sec), ...
